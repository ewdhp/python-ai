**orchestrator architecture with tasks, YAML config, status tracking, PID/log files, and optional scheduler queue**. Iâ€™ll annotate the components so you can see how CLI commands interact with each piece.

```
                         +---------------------+
                         | hl_monitor_config.yaml |
                         | (Task definitions)    |
                         +-----------+---------+
                                     |
                                     v
                         +---------------------+
                         |   Orchestrator CLI  |
                         |--------------------|
                         | list / run / stop   |
                         | pause / resume      |
                         | restart / status    |
                         | tail logs           |
                         +-----------+---------+
                                     |
                                     v
+---------------------+        +----------------------+
|  Task Objects (Python) |----->|   Scheduler Queue     | (optional)
|---------------------|        | - Tracks ready tasks |
| name, type, enabled |        | - Handles cron/daemon|
| steps, interval     |        +----------------------+
| runtime status      |
| pid, progress       |
+---------+-----------+
          |
          v
+---------------------+       +--------------------+
| PID Directory       |       | Logs Directory     |
| pids/<task>.pid     |       | logs/<task>.log    |
| - Tracks process id |       | - Captures stdout  |
|   for stop/pause    |       |   and step output  |
|   resume/restart    |       | - Supports tail -f |
+---------------------+       +--------------------+
          |
          v
+---------------------+
| Task Process Script |
|---------------------|
| - Executes steps    |
| - Updates progress  |
| - Writes logs       |
| - Handles signals   |
|   (SIGTERM/SIGSTOP) |
+---------------------+
```

---

### ðŸ”¹ Explanation

1. **YAML Config**

   * Defines all tasks, their types (`one-shot`, `daemon`, `cron`), steps, schedule, and enabled/disabled state.

2. **Orchestrator CLI**

   * Provides user interface to manage tasks (`run`, `stop`, `pause`, `resume`, `restart`, `status`, `tail`).
   * Reads config and interacts with **Task objects**, **PID files**, and **logs**.

3. **Task Objects (Python)**

   * In-memory representation of tasks.
   * Stores runtime state: `pid`, `progress`, `alerts`, `severity`.

4. **Scheduler Queue (Optional)**

   * For daemon or cron tasks.
   * Determines which tasks are ready to run.
   * Works with intervals or cron expressions.

5. **PID Directory**

   * Each task writes its PID when launched.
   * Orchestrator uses PID to send signals for `stop`, `pause`, `resume`.

6. **Logs Directory**

   * Each task writes stdout and step output to logs.
   * Supports `tail -f` for real-time monitoring in separate terminals.

7. **Task Process Script**

   * Independent Python script executing the task steps.
   * Updates progress in terminal (optional `rich` progress bar).
   * Handles termination/pausing/resuming signals gracefully.

---

This diagram shows **how CLI commands, configuration, runtime state, logs, and optional scheduler queue all interact** while keeping tasks independent and observable in their own terminals.

---

If you want, I can now **update the CLI skeleton to include `stop`, `pause`, `resume`, and `restart` commands using the PID files**, fully integrating this architecture.

Do you want me to do that next?
